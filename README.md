# Store  

### 구현 범위 

1. 브랜드, 상품을 추가, 수정, 삭제
2. 카테고리별 최저가격 브랜드와 상품 가격, 총액을 조회
3. 단일 브랜드로 모든 카테고리 상품 리스트 및 총액 조회
4. 카테고리 이름으로 최저, 최고 가격 브랜드와 상품 가격 조회
5. 통합테스트
6. 단위테스트 

### 설명

주어진 상품데이터를 Product라는 테이블에 저장합니다.

상품을 추가, 수정, 삭제를 통해 카테고리별 최저, 최고가격을 테이블로 관리, 업데이트 합니다.
상품을 추가, 수정, 삭제를 통해 브랜드별 모든 카테고리의 최저 총액을 테이블로 관리, 업데이트 합니다.

이렇게 유저에게 제공되는 조회성 데이터 (카테고리별 최저가격, 단일 브랜드의 모든 카테고리 최저가격) 은
인덱싱이 되어있다 하더라도 데이터베이스에 부하를 준다고 판단하여 테이블로 관리하기로 결정하였습니다.

또한, 운영상 운영자가 데이터를 추가, 수정, 삭제를 하고 이때, (카테고리별 최저가격, 단일 브랜드의 모든 카테고리 최저가격)이 결정
되기 때문에 캐싱을 하거나 테이블로 따로 저장하는게 낫다고 판단하였습니다.

그러다보면, 운영자가 데이터를 추가할때, 겹쳐서 최저가격이 제대로 업데이트되지 않을 경우가 존재하는데, 이 경우는
낙관적 락을 통해 업데이트 중에 다른 데이터가 들어오면 오류 메시지를 반환하여 재시도를 하도록 유도하였습니다.

나중에는 Queuing을 통해 들어온 순서대로 업데이트하는게 좋아보입니다.

---
카테고리별 최저가격을 저장하는 테이블에는 다음과 같은 데이터가 있습니다.
- 식별자
- 카테고리
- 최저가격 상품
- 최고가격 상품
---
단일 브랜드의 모든 카테고리 최저가격을 저장하는 테이블에는 다음과 같은 데이터가 있습니다.
- 식별자
- 브랜드
- 총합 

이 테이블은 매핑테이블을 갖고 있는데 매핑 테이블의 데이터는 다음과 같습니다.
- 식별자
- 단일 브랜드의 모든 카테고리 최저가격 테이블의 식별자 (FK)
- 상품 식별자(FK)


### API END-POINT
swagger를 사용하여 쉽게 볼 수 있도록 하였습니다.
<br>
http://localhost:8080/swagger-ui/index.html#/
<br>
<br>
상품 추가 , 수정, 삭제 
```bash
 post localhost:8080/product
 patch localhost:8080/product/{id}
 delete localhost:8080/product/{id}
```

브랜드 추가 , 수정, 삭제
```bash
 post localhost:8080/brand
 patch localhost:8080/brand/{id}
 delete localhost:8080/brand/{id}
```

카테고리별 최저가격 브랜드와 상품 가격, 총액을 조회
```bash
get localhost:8080/categories/lowest-price
```

단일 브랜드로 모든 카테고리 상품 리스트 및 총액 조회
```bash
get localhost:8080/brand/{brand-name}/lowest-price
```

카테고리 이름으로 최저, 최고 가격 브랜드와 상품 가격 조회
```bash
get localhost:8080/categories/{category-name}/lowest-price
```

### 실행 방법

Test run
```bash
./gradlew clean test
```

Server run
```bash
docker-compose up
```

